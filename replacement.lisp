(require :queue "queue.lisp")
(use-package :queue)

(defun knight-change (&optional (start #(1 1 1 0 0 0 0 0 0 2 2 2))
                                (goal  #(2 2 2 0 0 0 0 0 0 1 1 1)))
  (let ((que (make-queue))
        (ht  (make-hash-table :test #'equalp)))
    (enqueue que (list nil start))
    (setf (gethash start ht) t)
    (loop
      until (emptyp que)
      do (loop with state = (dequeue que)
               as from below 12
               unless (emptyp-placep state from)
               do (loop as to in (aref adjacent from)
                        when (emptyp-placep state to)
                        do (loop with board = (make-board state from to)
                                 with newst = (list state board)
                                 do (unless (gethash board ht)
                                      (enqueue que newst)
                                      (setf (gethash board ht) t))
                                 do (when (equalp board goal)
                                      (print-answer newst)
                                      (return-from knight-change))
                                 until t))))))

(defconstant adjacent
  #((5 7)
    (6 8)
    (3 7)
    (2 8 10)
    (9 11)
    (0 6 10)
    (1 5 11)
    (0 2)
    (1 3 9)
    (4 8)
    (3 5)
    (4 6)))

(defun print-answer (state)
  (when (car state)
    (print-answer (car state)))
  (print (second state)))

(defun make-board (state from to)
  (let ((board (copy-seq (second state))))
    (setf (aref board to) (aref board from)
          (aref board from) 0)
    board))

(defun emptyp-placep (state n)
  (zerop (aref (second state) n)))

(time (knight-change))
